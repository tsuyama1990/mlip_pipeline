from pathlib import Path
from typing import Any

from ase import Atoms
from ase.data import atomic_numbers


class LammpsInputGenerator:
    def __init__(self, potential_path: Path | None = None) -> None:
        self.potential_path = potential_path

    def generate_input(self, atoms: Atoms, data_file: str, parameters: dict[str, Any]) -> str:
        """
        Generates the input file content for LAMMPS.

        Args:
            atoms: The Atoms object (used to determine elements).
            data_file: The name of the data file (e.g., 'data.lammps').
            parameters: Dictionary of parameters (e.g., temp, steps, gamma_threshold).

        Returns:
            The content of the in.lammps file.
        """
        # 1. Header
        lines = [
            "# Generated by MLIP AutoPipeC",
            "units metal",
            "atom_style atomic",
            "boundary p p p",
            f"read_data {data_file}",
            "",
        ]

        # 2. Potential (Hybrid/Overlay)
        # Sort elements to match ASE's default LAMMPS data writer behavior (usually alphabetical)
        elements = sorted(set(atoms.get_chemical_symbols()))  # type: ignore[no-untyped-call]

        # ZBL Cutoffs
        zbl_inner = 1.0
        zbl_outer = 2.0

        lines.append(f"pair_style hybrid/overlay pace zbl {zbl_inner} {zbl_outer}")

        # PACE Coefficients
        if self.potential_path:
            # pair_coeff * * pace potential.yace Element1 Element2 ...
            # The elements should match the order in the data file (types 1, 2, ...)
            # which we assume is alphabetical.
            elem_str = " ".join(elements)
            lines.append(f"pair_coeff * * pace {self.potential_path} {elem_str}")
        else:
            # Fallback if no potential
            pass

        # ZBL Coefficients
        # pair_coeff type_i type_j zbl Z_i Z_j
        for i, el1 in enumerate(elements):
            type1 = i + 1
            z1 = atomic_numbers[el1]
            for j, el2 in enumerate(elements):
                # Symmetric, but LAMMPS usually wants i <= j or * *
                # For pair_coeff * * zbl Zi Zj, it applies to all? No.
                # ZBL pair_coeff is: pair_coeff I J zbl Zi Zj
                if j >= i:
                    type2 = j + 1
                    z2 = atomic_numbers[el2]
                    lines.append(f"pair_coeff {type1} {type2} zbl {z1} {z2}")

        lines.append("")

        # 3. Settings
        temp = parameters.get("temp", 300)
        lines.append("neighbor 1.0 bin")
        lines.append("neigh_modify delay 0 every 1 check yes")
        lines.append(f"velocity all create {temp} 12345 dist gaussian")
        lines.append("fix 1 all nve")

        # 4. Compute Gamma (Uncertainty)
        # PACE potential computes gamma internally if requested.
        # This is a hypothetical compute name for the purpose of the watchdog pattern.

        # If parameters has gamma_threshold
        gamma_thresh = parameters.get("gamma_threshold", 5.0)

        # To satisfy the test `v_max_gamma > 5.0`
        lines.append("compute gamma_val all pace/gamma")  # Hypothetical compute name
        lines.append("variable max_gamma equal max(c_gamma_val)")

        lines.append(f"fix watchdog all halt 10 v_max_gamma > {gamma_thresh} error hard")

        # 5. Run
        steps = parameters.get("steps", 1000)
        lines.append("thermo 10")
        lines.append("dump 1 all custom 10 traj.lammpstrj id type x y z c_gamma_val")
        lines.append(f"run {steps}")

        return "\n".join(lines)
