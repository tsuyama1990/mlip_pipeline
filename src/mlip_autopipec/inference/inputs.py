"""
Script Generator Module.

This module provides the ScriptGenerator class for creating LAMMPS input scripts.
"""

from pathlib import Path

from ase.data import atomic_numbers

from mlip_autopipec.config.schemas.inference import InferenceConfig, BaselinePotential


class ScriptGenerator:
    # Constants
    NEIGHBOR_SETTINGS = "neighbor 1.0 bin"
    NEIGH_MODIFY = "neigh_modify delay 0 every 1 check yes"
    TDAMP_MULTIPLIER = 100.0
    PDAMP_MULTIPLIER = 1000.0

    def __init__(self, config: InferenceConfig) -> None:
        self.config = config

    def generate(
        self, atoms_file: Path, potential_path: Path, dump_file: Path, elements: list[str]
    ) -> str:
        # Determine ensemble fix
        if self.config.ensemble == "nvt":
            tdamp = self.config.timestep * self.TDAMP_MULTIPLIER
            fix_cmd = (
                f"fix 1 all nvt temp {self.config.temperature} {self.config.temperature} {tdamp}"
            )
        elif self.config.ensemble == "npt":
            tdamp = self.config.timestep * self.TDAMP_MULTIPLIER
            pdamp = self.config.timestep * self.PDAMP_MULTIPLIER
            fix_cmd = f"fix 1 all npt temp {self.config.temperature} {self.config.temperature} {tdamp} iso {self.config.pressure} {self.config.pressure} {pdamp}"
        else:
            msg = f"Unsupported ensemble: {self.config.ensemble}"
            raise ValueError(msg)

        # Potential setup
        elements_str = " ".join(elements)

        potential_lines = []
        if self.config.baseline_potential == BaselinePotential.ZBL:
            potential_lines.append(
                f"pair_style hybrid/overlay pace {self.config.zbl_inner_cutoff} {self.config.zbl_outer_cutoff} zbl {self.config.zbl_inner_cutoff} {self.config.zbl_outer_cutoff}"
            )
            potential_lines.append(f"pair_coeff * * pace {potential_path.resolve()} {elements_str}")

            # Generate ZBL pair coefficients for all pairs
            for i, el1 in enumerate(elements, start=1):
                z1 = atomic_numbers[el1]
                for j, el2 in enumerate(elements, start=1):
                    if j >= i:
                        z2 = atomic_numbers[el2]
                        potential_lines.append(f"pair_coeff {i} {j} zbl {z1} {z2}")

        elif self.config.baseline_potential == BaselinePotential.LJ:
             potential_lines.append("pair_style hybrid/overlay pace 10.0 lj/cut 10.0")
             potential_lines.append(f"pair_coeff * * pace {potential_path.resolve()} {elements_str}")
             potential_lines.append("pair_coeff * * lj/cut 1.0 1.0")

        else: # None
            potential_lines.append("pair_style pace")
            potential_lines.append(f"pair_coeff * * {potential_path.resolve()} {elements_str}")

        lines = [
            "# LAMMPS input script generated by MLIP-AutoPipe",
            "units metal",
            "atom_style atomic",
            "boundary p p p",
            "box tilt large",
            f"read_data {atoms_file.resolve()}",
            "",
            "# Potential setup",
            *potential_lines,
            "",
            "# Settings",
            self.NEIGHBOR_SETTINGS,
            self.NEIGH_MODIFY,
            f"timestep {self.config.timestep}",
            "",
            "# Compute Gamma (Extrapolation Grade)",
            f"compute gamma all pace {potential_path.resolve()} {elements_str}",
            "variable max_gamma equal max(c_gamma)",
            "",
            "# Thermo output",
            "thermo_style custom step temp press pe v_max_gamma",
            f"thermo {self.config.sampling_interval}",
            "",
            "# Restart",
            f"restart {self.config.restart_interval} restart.*",
            "",
            "# Dump high uncertainty configurations",
            f"dump my_dump all custom {self.config.sampling_interval} {dump_file.resolve()} id type x y z fx fy fz c_gamma",
            f"dump_modify my_dump thresh c_gamma > {self.config.uncertainty_threshold}",
            # Note: dump_modify thresh usually requires per-atom value. c_gamma is per-atom.

            "",
            "# Watchdog Halt",
            # Halt if max gamma exceeds threshold
            f"fix watchdog all halt {self.config.sampling_interval} v_max_gamma > {self.config.uncertainty_threshold} error hard",
            "",
            "# Run",
            fix_cmd,
            f"run {self.config.steps}",
            "unfix 1",
        ]

        return "\n".join(lines)
