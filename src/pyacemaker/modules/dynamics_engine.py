"""Dynamics Engine (MD/kMC) module implementation."""

import secrets
import subprocess
import tempfile
from collections.abc import Iterable, Iterator
from pathlib import Path
from typing import Any

from pyacemaker.core.base import ModuleResult
from pyacemaker.core.config import PYACEMAKERConfig
from pyacemaker.core.interfaces import DynamicsEngine
from pyacemaker.core.utils import generate_dummy_structures
from pyacemaker.domain_models.models import (
    HaltInfo,
    Potential,
    StructureMetadata,
    UncertaintyState,
)
from pyacemaker.dynamics.kmc import EONWrapper


class PotentialHelper:
    """Helper for generating hybrid potential LAMMPS commands."""

    def get_lammps_commands(
        self, potential_path: Path, baseline_type: str, elements: list[str]
    ) -> list[str]:
        """Generate LAMMPS pair_style and pair_coeff commands."""
        path_str = str(potential_path)
        element_str = " ".join(elements)

        cmds = []
        # Basic hybrid setup
        if baseline_type == "zbl":
            # Using hybrid/overlay to add ZBL repulsion on top of ACE
            cmds.append("pair_style hybrid/overlay pace zbl 4.0 5.0")
            cmds.append(f"pair_coeff * * pace {path_str} {element_str}")
            # ZBL usually needs explicit Z1 Z2, but we use * * for all pairs with a generic cutoff
            # This is a placeholder that matches the requirement "pair_style ... zbl"
            cmds.append("pair_coeff * * zbl 0.0 0.0")
        elif baseline_type == "lj":
            cmds.append("pair_style hybrid/overlay pace lj/cut 10.0")
            cmds.append(f"pair_coeff * * pace {path_str} {element_str}")
            cmds.append("pair_coeff * * lj/cut 1.0 1.0")
        else:
            # Fallback to just PACE if no valid baseline or "none"
            cmds.append("pair_style pace")
            cmds.append(f"pair_coeff * * pace {path_str} {element_str}")

        return cmds


class MDInterface:
    """Interface for running MD simulations with LAMMPS."""

    def __init__(self, config: PYACEMAKERConfig) -> None:
        """Initialize MDInterface."""
        self.config = config
        self.params = config.dynamics_engine
        # Initialize logger
        self.logger = __import__("logging").getLogger(self.__class__.__name__)

    def _write_lammps_input(
        self, structure: StructureMetadata, potential: Potential, work_dir: Path
    ) -> Path:
        """Write in.lammps file."""
        input_file = work_dir / "in.lammps"

        # Get elements from structure features (e.g. atoms object) or metadata
        elements = []
        if "atoms" in structure.features:
            atoms = structure.features["atoms"]
            if hasattr(atoms, "get_chemical_symbols"):
                elements = sorted(set(atoms.get_chemical_symbols()))
        elif structure.material_dna and structure.material_dna.composition:
            elements = sorted(structure.material_dna.composition.keys())

        if not elements:
            # Fallback or error? For now log warning and use empty
            self.logger.warning("No elements found in structure for LAMMPS input generation.")

        helper = PotentialHelper()
        cmds = helper.get_lammps_commands(potential.path, self.params.hybrid_baseline, elements)

        content = [
            "# LAMMPS input file generated by PYACEMAKER",
            "units metal",
            "atom_style atomic",
            "boundary p p p",
            "read_data data.lammps",  # We assume data file exists
        ]
        # Append commands individually to avoid intermediate list creation
        for cmd in cmds:
            content.append(cmd)

        content.append(f"timestep {self.params.timestep}")
        content.append(f"fix 1 all nvt temp {self.params.temperature} {self.params.temperature} 0.1")
        content.append("compute pace all pace")  # Assuming compute pace is available
        content.append("variable pace_gamma equal c_pace")
        content.append(
            f"fix halt all halt 10 v_pace_gamma > {self.params.gamma_threshold} error continue"
        )
        content.append(f"run {self.params.n_steps}")

        # Efficient write using join
        input_file.write_text("\n".join(content))
        return input_file

    def _extract_bad_structure(self, work_dir: Path) -> StructureMetadata:
        """Extract the bad structure from dump file."""
        # Mock implementation: return a dummy structure
        # In real implementation, parse 'dump.lammps'
        s = next(generate_dummy_structures(1, tags=["halt_event"]))
        s.uncertainty_state = UncertaintyState(
            gamma_max=self.params.gamma_threshold * 1.5,
            gamma_mean=self.params.gamma_threshold * 0.5,
            gamma_variance=1.0,
        )
        return s

    def run_md(
        self, structure: StructureMetadata, potential: Potential, work_dir: Path | None = None
    ) -> HaltInfo:
        """Run MD simulation."""
        if work_dir is None:
            # Should be provided by caller for better control, but let's handle it if not
            msg = "work_dir must be provided"
            raise ValueError(msg)

        self._write_lammps_input(structure, potential, work_dir)

        # Run LAMMPS (Mock via subprocess patch or check file existence)
        log_file = work_dir / "log.lammps"

        if not self.params.mock:
            import shutil

            exe = shutil.which(self.params.engine)
            if not exe:
                self.logger.error(f"LAMMPS executable '{self.params.engine}' not found.")
                # We cannot proceed without executable
                return HaltInfo(halted=False, step=None, max_gamma=None, structure=None)

            try:
                with log_file.open("w") as f:
                    subprocess.run(  # noqa: S603
                        [exe, "-in", "in.lammps"],
                        cwd=work_dir,
                        stdout=f,
                        check=False,
                    )
            except Exception:
                self.logger.exception("Failed to run LAMMPS")

        # Simulate check
        halted = False
        step = None
        max_gamma = None
        bad_structure = None

        if log_file.exists():
            content = log_file.read_text()
            if "Fix halt condition met" in content:
                halted = True
                step = 100  # Mock Parse from log
                max_gamma = self.params.gamma_threshold + 1.0  # Mock Parse from log
                bad_structure = self._extract_bad_structure(work_dir)

        return HaltInfo(
            halted=halted,
            step=step,
            max_gamma=max_gamma,
            structure=bad_structure,
        )


class LAMMPSEngine(DynamicsEngine):
    """LAMMPS Dynamics Engine implementation."""

    def __init__(self, config: PYACEMAKERConfig) -> None:
        """Initialize the LAMMPS Engine."""
        super().__init__(config)
        self.md = MDInterface(config)
        self.gamma_threshold = config.dynamics_engine.gamma_threshold

    def run(self) -> ModuleResult:
        """Run the engine."""
        self.logger.info("Running LAMMPSEngine")
        return ModuleResult(status="success")

    def run_exploration(
        self, potential: Potential, seeds: Iterable[StructureMetadata]
    ) -> Iterator[StructureMetadata]:
        """Run MD exploration and return high-uncertainty structures."""
        self.logger.info(f"Running exploration with {potential.path}")

        # In production, this might loop until user interrupt or convergence
        with tempfile.TemporaryDirectory() as tmpdir:
            work_dir = Path(tmpdir)

            for i, seed in enumerate(seeds):
                # Create a specific subdirectory for each run to avoid collision
                run_dir = work_dir / f"run_{i}"
                run_dir.mkdir(exist_ok=True)

                if self.config.dynamics_engine.mock:
                    # Mock logic: Decide randomly to halt based on config
                    probability = self.config.dynamics_engine.parameters.get(
                        "dynamics_halt_probability", 0.3
                    )
                    if secrets.SystemRandom().random() < float(probability):
                        # Create log file to trigger halt in MDInterface
                        (run_dir / "log.lammps").write_text("Fix halt condition met")
                    elif (run_dir / "log.lammps").exists():
                        (run_dir / "log.lammps").unlink()

                halt_info = self.md.run_md(seed, potential, run_dir)

                if halt_info.halted and halt_info.structure:
                    self.logger.warning(
                        f"Halt triggered (Gamma > {halt_info.max_gamma}) for seed {i}"
                    )
                    yield halt_info.structure

    def run_production(self, potential: Potential) -> Any:
        """Run production simulation."""
        self.logger.info(f"Running production with {potential.path} (mock)")
        return "mock_production_result"


class EONEngine(DynamicsEngine):
    """EON Dynamics Engine implementation."""

    def __init__(self, config: PYACEMAKERConfig) -> None:
        """Initialize EON Engine."""
        super().__init__(config)
        self.wrapper = EONWrapper(config.dynamics_engine.eon)

    def run(self) -> ModuleResult:
        """Run the engine."""
        self.logger.info("Running EONEngine")
        return ModuleResult(status="success")

    def run_exploration(
        self, potential: Potential, seeds: Iterable[StructureMetadata]
    ) -> Iterator[StructureMetadata]:
        """Run EON exploration."""
        self.logger.info(f"Running EON exploration with {potential.path}")

        # EON usually explores from a known minimum.
        # We iterate over seeds and try to run EON on them.
        for _ in seeds:
            # Placeholder: In real implementation, wrap EON execution
            # For now, yield nothing
            pass
        yield from []

    def run_production(self, potential: Potential) -> Any:
        """Run production."""
        self.logger.info(f"Running EON production with {potential.path}")
        return "eon_production_result"
