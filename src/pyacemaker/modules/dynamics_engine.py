"""Dynamics Engine (MD/kMC) module implementation."""

import secrets
import subprocess
import tempfile
from collections.abc import Iterator
from pathlib import Path
from typing import Any

from pyacemaker.core.base import ModuleResult
from pyacemaker.core.config import PYACEMAKERConfig
from pyacemaker.core.interfaces import DynamicsEngine
from pyacemaker.core.utils import generate_dummy_structures
from pyacemaker.domain_models.models import (
    HaltInfo,
    Potential,
    StructureMetadata,
    UncertaintyState,
)


class PotentialHelper:
    """Helper for generating hybrid potential LAMMPS commands."""

    def get_lammps_commands(
        self, potential_path: Path, baseline_type: str, elements: list[str]
    ) -> list[str]:
        """Generate LAMMPS pair_style and pair_coeff commands."""
        path_str = str(potential_path)
        element_str = " ".join(elements)

        cmds = []
        # Basic hybrid setup
        if baseline_type == "zbl":
            # Using hybrid/overlay to add ZBL repulsion on top of ACE
            cmds.append("pair_style hybrid/overlay pace zbl 4.0 5.0")
            cmds.append(f"pair_coeff * * pace {path_str} {element_str}")
            # ZBL usually needs explicit Z1 Z2, but we use * * for all pairs with a generic cutoff
            # This is a placeholder that matches the requirement "pair_style ... zbl"
            cmds.append("pair_coeff * * zbl 0.0 0.0")
        elif baseline_type == "lj":
            cmds.append("pair_style hybrid/overlay pace lj/cut 10.0")
            cmds.append(f"pair_coeff * * pace {path_str} {element_str}")
            cmds.append("pair_coeff * * lj/cut 1.0 1.0")
        else:
            # Fallback to just PACE if no valid baseline or "none"
            cmds.append("pair_style pace")
            cmds.append(f"pair_coeff * * pace {path_str} {element_str}")

        return cmds


class MDInterface:
    """Interface for running MD simulations with LAMMPS."""

    def __init__(self, config: PYACEMAKERConfig) -> None:
        """Initialize MDInterface."""
        self.config = config
        self.params = config.dynamics_engine
        # Initialize logger
        self.logger = __import__("logging").getLogger(self.__class__.__name__)

    def _write_lammps_input(
        self, structure: StructureMetadata, potential: Potential, work_dir: Path
    ) -> Path:
        """Write in.lammps file."""
        input_file = work_dir / "in.lammps"

        # Get elements from structure features (e.g. atoms object) or metadata
        elements = []
        if "atoms" in structure.features:
            atoms = structure.features["atoms"]
            if hasattr(atoms, "get_chemical_symbols"):
                elements = sorted(set(atoms.get_chemical_symbols()))
        elif structure.material_dna and structure.material_dna.composition:
            elements = sorted(structure.material_dna.composition.keys())

        if not elements:
            # Fallback or error? For now log warning and use empty
            self.logger.warning("No elements found in structure for LAMMPS input generation.")

        helper = PotentialHelper()
        cmds = helper.get_lammps_commands(potential.path, self.params.hybrid_baseline, elements)

        content = [
            "# LAMMPS input file generated by PYACEMAKER",
            "units metal",
            "atom_style atomic",
            "boundary p p p",
            "read_data data.lammps",  # We assume data file exists
        ]
        content.extend(cmds)
        content.extend(
            [
                f"timestep {self.params.timestep}",
                f"fix 1 all nvt temp {self.params.temperature} {self.params.temperature} 0.1",
                "compute pace all pace",  # Assuming compute pace is available
                "variable pace_gamma equal c_pace",
                f"fix halt all halt 10 v_pace_gamma > {self.params.gamma_threshold} error continue",
                f"run {self.params.n_steps}",
            ]
        )

        input_file.write_text("\n".join(content))
        return input_file

    def _extract_bad_structure(self, work_dir: Path) -> StructureMetadata:
        """Extract the bad structure from dump file."""
        # Mock implementation: return a dummy structure
        # In real implementation, parse 'dump.lammps'
        s = next(generate_dummy_structures(1, tags=["halt_event"]))
        s.uncertainty_state = UncertaintyState(
            gamma_max=self.params.gamma_threshold * 1.5,
            gamma_mean=self.params.gamma_threshold * 0.5,
            gamma_variance=1.0,
        )
        return s

    def run_md(
        self, structure: StructureMetadata, potential: Potential, work_dir: Path | None = None
    ) -> HaltInfo:
        """Run MD simulation."""
        if work_dir is None:
            # Should be provided by caller for better control, but let's handle it if not
            msg = "work_dir must be provided"
            raise ValueError(msg)

        self._write_lammps_input(structure, potential, work_dir)

        # Run LAMMPS (Mock via subprocess patch or check file existence)
        log_file = work_dir / "log.lammps"

        if not self.params.mock:
            try:
                with log_file.open("w") as f:
                    subprocess.run(  # noqa: S603
                        [self.params.engine, "-in", "in.lammps"],
                        cwd=work_dir,
                        stdout=f,
                        check=False,
                    )
            except FileNotFoundError:
                self.logger.exception(f"LAMMPS executable '{self.params.engine}' not found.")
            except Exception:
                self.logger.exception("Failed to run LAMMPS")

        # Simulate check
        halted = False
        step = None
        max_gamma = None
        bad_structure = None

        if log_file.exists():
            content = log_file.read_text()
            if "Fix halt condition met" in content:
                halted = True
                step = 100  # Mock Parse from log
                max_gamma = self.params.gamma_threshold + 1.0  # Mock Parse from log
                bad_structure = self._extract_bad_structure(work_dir)

        return HaltInfo(
            halted=halted,
            step=step,
            max_gamma=max_gamma,
            structure=bad_structure,
        )


class LAMMPSEngine(DynamicsEngine):
    """LAMMPS Dynamics Engine implementation."""

    def __init__(self, config: PYACEMAKERConfig) -> None:
        """Initialize the LAMMPS Engine."""
        super().__init__(config)
        self.md = MDInterface(config)
        self.gamma_threshold = config.dynamics_engine.gamma_threshold

    def run(self) -> ModuleResult:
        """Run the engine."""
        self.logger.info("Running LAMMPSEngine")
        return ModuleResult(status="success")

    def run_exploration(self, potential: Potential) -> Iterator[StructureMetadata]:
        """Run MD exploration and return high-uncertainty structures."""
        self.logger.info(f"Running exploration with {potential.path}")

        if not self.config.dynamics_engine.mock:
            # Real implementation would need a starting structure source.
            # Since interface doesn't provide it, we assume it picks from dataset or uses generator.
            # For now, warn and fallback to dummy or return empty if strictly real.
            self.logger.warning("Real exploration logic requires starting structure source.")
            return

        # For mock simulation of the loop:
        # In production, this might loop until user interrupt or convergence
        with tempfile.TemporaryDirectory() as tmpdir:
            work_dir = Path(tmpdir)

            # Simulate a few checks or "runs"
            for _ in range(3):
                # Create a dummy structure to start with
                initial_structure = next(generate_dummy_structures(1, tags=["initial"]))

                # Mock the log file creation for test purpose if needed
                # In this "mock" exploration, we decide randomly to halt
                probability = self.config.dynamics_engine.parameters.get(
                    "dynamics_halt_probability", 0.3
                )
                if secrets.SystemRandom().random() < float(probability):
                    # Create log file to trigger halt in MDInterface
                    (work_dir / "log.lammps").write_text("Fix halt condition met")
                elif (work_dir / "log.lammps").exists():
                    (work_dir / "log.lammps").unlink()

                halt_info = self.md.run_md(initial_structure, potential, work_dir)

                if halt_info.halted and halt_info.structure:
                    self.logger.warning(f"Halt triggered (Gamma > {halt_info.max_gamma})")
                    yield halt_info.structure

    def run_production(self, potential: Potential) -> Any:
        """Run production simulation."""
        self.logger.info(f"Running production with {potential.path} (mock)")
        return "mock_production_result"
