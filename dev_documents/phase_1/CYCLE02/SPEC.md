# CYCLE02: Surrogate-First Exploration (SPEC.md)

## 1. Summary

This document provides the detailed technical specification for Cycle 2 of the MLIP-AutoPipe project. The focus of this cycle is to introduce a critical layer of intelligence and efficiency into the data generation pipeline. The core problem with a naive active learning approach is that it can waste an enormous amount of expensive DFT resources on structures that are either physically nonsensical, redundant, or simply not very informative. This cycle addresses that problem directly by creating a **Surrogate-First Exploration** module. The central idea is to use a fast, general-purpose, pre-trained machine learning potential—a "surrogate" model—as an inexpensive filter and guide before committing to any new DFT calculations.

The main deliverable for this cycle is a `SurrogateExplorer` class, which will be responsible for two key tasks. First, it will perform a rapid **pre-screening** of a large batch of candidate structures. Using a surrogate model like MACE (which has been trained on a massive general-purpose dataset), the explorer will evaluate the forces and energies of these candidate structures. Any structure that is physically implausible—for instance, one where atoms are too close, leading to gigantic forces—will be immediately discarded. This step is crucial for filtering out the unphysical configurations that can be generated by aggressive sampling techniques (like large rattling or distortion).

Second, for the structures that pass this initial check, the `SurrogateExplorer` will perform an intelligent **down-selection** to ensure the final batch sent to the DFT Factory is maximally diverse and informative. This will be achieved using the Farthest Point Sampling (FPS) algorithm. The module will first convert each atomic structure into a numerical "fingerprint" that represents its local atomic environment. Then, using these fingerprints as points in a high-dimensional space, the FPS algorithm will select a small subset of structures that are as far apart from each other as possible. This process ensures that the system does not waste DFT calculations on many very similar structures, instead prioritising those that represent genuinely new and different configurations. By the end of this cycle, the project will have a powerful tool to intelligently curate the data used for training, dramatically improving the computational efficiency of the entire workflow.

## 2. System Architecture

The architecture for Cycle 2 introduces a new module responsible for exploration and selection, located at `mlip_autopipec/modules/exploration.py`. This module is designed to be a pure function: it takes a list of structures and returns a smaller, filtered list of structures.

**File Structure for Cycle 2:**

The following ASCII tree shows the new files to be created in this cycle, marked in **bold**.

```
mlip-autopipe/
├── dev_documents/
│   └── system_prompts/
│       ├── CYCLE01/
│       └── CYCLE02/
│           ├── **SPEC.md**
│           └── **UAT.md**
├── mlip_autopipec/
│   ├── modules/
│   │   ├── __init__.py
│   │   ├── dft.py
│   │   └── **exploration.py**  # Core Surrogate Explorer implementation
│   └── utils/
│       └── ase_utils.py
├── tests/
│   └── modules/
│       ├── __init__.py
│       ├── test_dft.py
│       └── **test_exploration.py** # Unit tests for exploration.py
└── pyproject.toml
```

**Component Blueprint: `modules/exploration.py`**

This file will contain the `SurrogateExplorer` class and its dependencies.

-   **`SurrogateExplorer` class:**
    -   **`__init__(self, explorer_config)`**: The constructor will take a Pydantic configuration object. This object will specify parameters such as the path to the pre-trained surrogate model file, the force threshold for the pre-screening step, and the type of structural fingerprint to use (e.g., SOAP).
    -   **`select(self, structures: List[ase.Atoms], num_to_select: int) -> List[ase.Atoms]`**: This is the main public method. It orchestrates the entire selection workflow. It will take a list of candidate `ase.Atoms` objects and the desired number of final structures. It will return a new, smaller list of `ase.Atoms` objects that have been screened and selected.
    -   **`_pre_screen_structures(self, structures: List[ase.Atoms]) -> List[ase.Atoms]`**: A private method that filters out unstable structures. It will load the MACE model once and then iterate through the list of input structures. For each structure, it will perform a quick force calculation with MACE. If the maximum force on any atom exceeds a configured threshold (e.g., 10 eV/Å), the structure is considered unstable and rejected. It returns a list of the structures that passed the screening.
    -   **`_calculate_fingerprints(self, structures: List[ase.Atoms]) -> np.ndarray`**: This helper method takes a list of `ase.Atoms` objects and computes a structural fingerprint for each one. It will use a library like `dscribe` to generate SOAP (Smooth Overlap of Atomic Positions) vectors. The output will be a 2D NumPy array where each row is the fingerprint vector for a structure.
    -   **`_farthest_point_sampling(self, fingerprints: np.ndarray, num_to_select: int) -> List[int]`**: This method implements the FPS algorithm. It takes the array of fingerprint vectors and the target number of selections. It iteratively selects points that are maximally distant from the set of already-selected points. It returns a list of *indices* corresponding to the selected structures in the original fingerprint array.

This design cleanly separates the three main responsibilities of the module: screening, fingerprinting, and sampling. This makes the code easier to understand, maintain, and test.

## 3. Design Architecture

The design of Cycle 2 continues the Schema-First approach, ensuring data integrity as structures are passed through the exploration pipeline. The primary data types are `ase.Atoms` objects and NumPy arrays for fingerprints, but the configuration of the module itself will be strictly controlled by Pydantic models.

**Pydantic Schema Definitions:**

The following Pydantic models will be added to `mlip_autopipec/config/models.py`.

1.  **`FingerprintConfig(BaseModel)`**: Defines the parameters for generating structural fingerprints. This allows for easy extension to other fingerprint types in the future.
    -   `type: Literal['soap'] = 'soap'`: Specifies the fingerprint algorithm to use.
    -   `soap_rcut: float = Field(5.0, gt=0)`: The cutoff radius for the SOAP descriptors.
    -   `soap_nmax: int = Field(8, gt=0)`: The number of radial basis functions.
    -   `soap_lmax: int = Field(6, gt=0)`: The maximum angular momentum.
    -   `species: List[str]`: A list of all chemical element symbols to be considered in the fingerprint.

2.  **`ExplorerConfig(BaseModel)`**: The main configuration object for the `SurrogateExplorer`.
    -   `surrogate_model_path: FilePath`: The path to the pre-trained MACE model file. `FilePath` from Pydantic ensures the file exists.
    -   `max_force_threshold: float = Field(10.0, gt=0)`: The force threshold in eV/Å for the pre-screening step.
    -   `fingerprint: FingerprintConfig`: A nested model containing the fingerprint configuration.
    -   `model_config = ConfigDict(extra='forbid')`: Prevents extraneous configuration fields.

**Data Flow and Consumers:**

-   **Producer:** The `StructureGenerator` (from a future cycle) will be the primary producer of the initial, large list of `ase.Atoms` objects.
-   **Consumer/Producer:** The `SurrogateExplorer` is both a consumer and a producer. It consumes the large list of `ase.Atoms` objects and produces a smaller, curated list of `ase.Atoms` objects.
-   **Internal Data:** Within the `SurrogateExplorer`, the data is transformed from a list of `ase.Atoms` objects into a NumPy array of fingerprint vectors. The FPS algorithm consumes this array and produces a list of integer indices. This list of indices is then used to select the final `ase.Atoms` objects.
-   **Final Consumer:** The `DFTFactory` from Cycle 1 will be the ultimate consumer of the list of structures produced by the `SurrogateExplorer`.

**Invariants and Constraints:**
-   The number of structures returned by the `select` method must be less than or equal to `num_to_select`.
-   The number of structures returned by `select` must be less than or equal to the number of input structures.
-   All returned structures must be a subset of the input structures that passed the pre-screening step.
-   The fingerprint generation must be deterministic: given the same `ase.Atoms` object and the same configuration, it must always produce the exact same fingerprint vector. This is critical for reproducibility.

This design ensures that the complex process of selection is governed by a clear, validated configuration, and that the data transformations within the module are well-defined.

## 4. Implementation Approach

The implementation of the `SurrogateExplorer` will be done in a bottom-up fashion, starting with the core algorithms (fingerprinting and FPS) and then integrating them into the main class.

1.  **Add Dependencies:** The `pyproject.toml` file will be updated to include new dependencies required for this cycle, such as `dscribe` for SOAP fingerprints and a suitable MACE implementation (`mace-torch`).

2.  **Implement Fingerprinting:** In `modules/exploration.py`, create the `_calculate_fingerprints` method. This will involve using the `dscribe.descriptors.SOAP` class. The method will instantiate the class using the parameters from the `FingerprintConfig` Pydantic model and then use the `create()` method on the list of `ase.Atoms` objects to generate the NumPy array of vectors.

3.  **Implement Farthest Point Sampling:** Implement the `_farthest_point_sampling` method. This is a standard algorithm that can be implemented with NumPy.
    -   Initialize an empty list for selected indices.
    -   Pick a random point as the first selected point.
    -   In a loop for `num_to_select` iterations:
        -   For all non-selected points, calculate the minimum distance to any of the already-selected points.
        -   Choose the point that has the maximum of these minimum distances.
        -   Add this point's index to the selected list.
    -   Return the list of selected indices.

4.  **Implement MACE Pre-screening:** Implement the `_pre_screen_structures` method. This will involve:
    -   Loading the pre-trained MACE model from the file specified in the `ExplorerConfig`.
    -   Creating a MACE calculator object.
    -   Iterating through the input structures. For each one, attach the MACE calculator, get the forces using `atoms.get_forces()`, and check if the maximum force magnitude exceeds the configured threshold.
    -   Collect and return all structures that pass the check.

5.  **Assemble the `SurrogateExplorer` Class:** Create the `SurrogateExplorer` class and its `__init__` method.
    -   Implement the main `select` method. This method will orchestrate the calls to the private methods in the correct order:
        1.  Call `_pre_screen_structures` on the initial list of structures.
        2.  If the number of surviving structures is less than `num_to_select`, simply return the surviving structures.
        3.  Otherwise, call `_calculate_fingerprints` on the list of screened structures.
        4.  Call `_farthest_point_sampling` on the fingerprint array to get the indices of the final selection.
        5.  Use these indices to build and return the final list of `ase.Atoms` objects.

6.  **Integrate Configuration:** Update `config/models.py` to include the new `FingerprintConfig` and `ExplorerConfig` Pydantic models. Ensure the `SurrogateExplorer`'s constructor accepts and uses the `ExplorerConfig` model.

This step-by-step process ensures each logical component is implemented and can be unit-tested before being integrated into the final class, simplifying development and debugging.

## 5. Test Strategy

Testing for Cycle 2 is crucial to ensure the efficiency and intelligence of the selection process. Tests will cover the core algorithms in isolation (unit tests) and the full pipeline in an integrated fashion.

**Unit Testing Approach (Min 300 words):**

Unit tests in `tests/modules/test_exploration.py` will validate the correctness of each component of the `SurrogateExplorer` independently.

-   **Testing FPS:** The FPS algorithm will be tested with a deterministic, simple 2D dataset. For example, we can create a set of points on a grid and a few outliers. The test `test_fps_selects_outliers` will assert that the FPS algorithm correctly picks the outlier points first, as they are farthest from the main cluster. Another test, `test_fps_returns_correct_number_of_points`, will ensure that if we ask for `k` points, we always get exactly `k` indices back (unless the input has fewer than `k` points).

-   **Testing Pre-screening Logic:** We will create two `ase.Atoms` objects for testing the `_pre_screen_structures` method. The first, `stable_structure`, will be a simple, equilibrium structure. The second, `unstable_structure`, will be created by taking the stable one and moving two atoms to be almost on top of each other (e.g., 0.5 Å apart). We will use a mock MACE model that returns a low force for the stable structure and a very high force for the unstable one. The test will assert that when a list containing both structures is passed to the method, the returned list contains only the `stable_structure`.

-   **Testing Fingerprinting:** To test `_calculate_fingerprints`, we will create a simple, known `ase.Atoms` object (e.g., a water molecule). We will run the fingerprint calculation and assert that the output NumPy array has the correct shape (1 row, N features). We will also run the function twice on the same structure and assert that the two resulting vectors are identical using `np.array_equal`, confirming the process is deterministic.

**Integration Testing Approach (Min 300 words):**

Integration tests will validate the entire workflow of the `SurrogateExplorer` from end to end, confirming that all the unit-tested components work together as expected.

-   **End-to-End Selection Test:** The main integration test will be `test_select_pipeline`. It will start by creating a large list (e.g., 200) of `ase.Atoms` objects. These will be generated by taking a single base structure and applying a series of small, random perturbations. This creates a list of similar, redundant structures. The test will then instantiate a real `SurrogateExplorer` (using a real, lightweight pre-trained MACE model) and call the `select` method, requesting a small number of structures (e.g., 10). The assertions will be:
    1.  The number of returned structures is exactly 10.
    2.  All 10 returned structures are members of the original input list.
    3.  The test will calculate the pairwise distance between the fingerprints of the selected structures and assert that the average distance is significantly larger than the average distance for a random sample of 10 structures from the original set. This quantitatively proves that FPS is selecting a more diverse set.

-   **Pipeline with Unstable Structures:** Another integration test will expand on the previous one. It will add a few known-unstable structures (with overlapping atoms) into the initial large list. It will then run the full `select` pipeline. The test will assert that none of the known-unstable structures are present in the final returned list, proving that the pre-screening and selection stages are correctly chained together.
