# Cycle 03: Oracle (DFT) Specification

## 1. Summary

Cycle 03 implements the **Oracle** component, which serves as the "source of truth" for the active learning pipeline. Its primary responsibility is to calculate the energy, forces, and stress tensors for atomic configurations generated by the Structure Generator or extracted from dynamics simulations. The implementation will focus on interfacing with **Quantum Espresso (QE)** and **VASP**, providing robust error handling and self-correction mechanisms for SCF convergence failures. Additionally, this cycle introduces the **Periodic Embedding** logic, a crucial feature for extracting small, manageable clusters from large-scale MD simulations for efficient DFT calculation while minimizing surface artifacts.

## 2. System Architecture

This cycle focuses on the `components/oracle` package and integration with `ase.calculators`.

### File Structure

The following file structure will be created. **Bold** files are to be implemented in this cycle.

*   **`src/`**
    *   **`mlip_autopipec/`**
        *   **`components/`**
            *   **`oracle/`**
                *   **`__init__.py`**
                *   **`base_oracle.py`** (Abstract Base Class)
                *   **`qe_oracle.py`** (Quantum Espresso Implementation)
                *   **`vasp_oracle.py`** (VASP Implementation - Optional/Stub)
                *   **`mock_oracle.py`** (For testing/CI)
                *   **`embedding.py`** (Periodic Embedding Logic)
                *   **`error_handler.py`** (Self-Correction Logic)

## 3. Design Architecture

### 3.1 Components

#### `BaseOracle`
Defines the standard interface for all DFT engines.
*   **`compute(structures: list[Structure]) -> list[CalculationResult]`**:
    *   Input: A list of `Structure` objects.
    *   Output: A list of `CalculationResult` objects containing energy, forces, stress, and metadata.
    *   Behavior: Handles parallel execution (if configured) and delegates to concrete implementations.

#### `QEOracle`
Concrete implementation for Quantum Espresso using `ase.calculators.espresso`.
*   **`__init__(config: QEOracleConfig)`**: Sets up pseudopotentials, k-points, and command paths.
*   **`_prepare_input(structure: Structure)`**: Generates the `pw.x` input file. Handles automatic k-spacing.
*   **`_run_calculation(structure: Structure)`**: Executes `pw.x` and parses output.
*   **`_handle_error(error: QEError, structure: Structure)`**: Attempts to fix convergence issues (e.g., reduce mixing beta, increase smearing) and retries.

#### `PeriodicEmbedding`
Logic for cutting clusters from large systems.
*   **`embed(structure: Structure, center_atom_index: int, radius: float) -> Structure`**:
    *   Input: A large MD snapshot and a focal point.
    *   Output: A small, periodic supercell containing the local environment of the focal atom, padded with a buffer region.
    *   Logic: Ensures that the cut cluster is not just a vacuum-surrounded molecule but a proper periodic representation of the bulk environment.

#### `MockOracle`
A lightweight implementation for CI/CD and testing.
*   **`compute(structures: list[Structure]) -> list[CalculationResult]`**:
    *   Returns pre-calculated values or uses a simple Lennard-Jones potential to generate consistent "fake" DFT data instantly.

### 3.2 Domain Models

*   **`CalculationResult`**:
    *   `energy: float`
    *   `forces: list[list[float]]`
    *   `stress: list[list[float]]`
    *   `converged: bool`
    *   `meta: dict` (e.g., `wall_time`, `scf_steps`)

*   **`QEOracleConfig`**:
    *   `pseudopotentials: dict[str, str]` (Path to UPF files)
    *   `kspacing: float` (Inverse grid density)
    *   `command: str` (e.g., `mpirun -np 4 pw.x`)

## 4. Implementation Approach

1.  **Mock Implementation**: Implement `MockOracle` first to enable testing of the interface without external dependencies.
2.  **ASE Integration**: Use `ase.calculators.espresso` as the driver. Ensure it is correctly configured via Pydantic models.
3.  **Input Generation**: Implement robust logic for k-point generation based on `kspacing` (using `ase.calculators.calculator.kpts2mp`).
4.  **Error Handling**: Create a `ErrorHandler` class that catches `QEError` (from ASE) and modifies the calculator parameters (mixing, diagonalization) for a retry.
5.  **Embedding**: Implement the `PeriodicEmbedding.embed` method. This requires careful handling of periodic boundary conditions and minimum image conventions.
6.  **Configuration**: Update `config.py` with `OracleConfig` and `QEOracleConfig`.
7.  **Factory**: Register `QEOracle` and `MockOracle` in `ComponentFactory`.

## 5. Test Strategy

### 5.1 Unit Testing
*   **`test_embedding.py`**:
    *   Create a large supercell (e.g., 5x5x5).
    *   Select a center atom.
    *   Call `embed` with a radius of 6.0 Ã….
    *   Assert that the returned structure is smaller than the original but contains the correct local environment.
    *   Verify periodic boundary conditions are respected.
*   **`test_qe_input.py`**:
    *   Initialize `QEOracle` with specific settings.
    *   Generate input for a dummy structure.
    *   Verify that `k_points` are calculated correctly from `kspacing`.
    *   Verify that `tprnfor` and `tstress` are set to `.true.`.

### 5.2 Integration Testing (Mocked)
*   **Orchestrator Integration**:
    *   Configure Orchestrator to use `MockOracle`.
    *   Pass a list of structures.
    *   Verify that `compute` returns a list of valid `CalculationResult` objects with energies and forces.
    *   Verify that results are consistent (same input -> same output).

### 5.3 Integration Testing (Real - Optional)
*   **Real QE Run**:
    *   Requires `pw.x` in the path.
    *   Run a calculation on a simple Silicon primitive cell.
    *   Verify that the calculated energy matches a reference value within 1 meV.
    *   This test should be skipped if `pw.x` is missing (CI environment).
