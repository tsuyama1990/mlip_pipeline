# CYCLE 01 Specification: Skeleton & Basic Loop

## 1. Summary

The goal of Cycle 01 is to establish the fundamental software architecture of the PYACEMAKER project. We will implement the core `Orchestrator` and a set of "Mock" components (`MockExplorer`, `MockOracle`, `MockTrainer`) that adhere to the system's interfaces. This allows us to verify the control flow of the active learning loop (Exploration -> DFT -> Training -> Validation) without needing to install or configure complex external physics engines like LAMMPS or Quantum Espresso yet. We will also define the rigorous Pydantic configuration schemas that will govern the application.

## 2. System Architecture

We will create the directory structure and the initial set of files.

```ascii
src/mlip_autopipec/
├── __init__.py
├── main.py                  # [CREATE] CLI Entrypoint (Typer)
├── config/
│   ├── __init__.py
│   └── config_model.py      # [CREATE] Pydantic Configuration Models
├── domain_models/
│   ├── __init__.py
│   └── structures.py        # [CREATE] StructureMetadata definition
├── interfaces/
│   ├── __init__.py
│   └── core_interfaces.py   # [CREATE] Protocol definitions (Explorer, Oracle, etc.)
├── orchestration/
│   ├── __init__.py
│   ├── orchestrator.py      # [CREATE] Main Loop Logic
│   └── mocks.py             # [CREATE] Mock implementations
└── utils/
    ├── __init__.py
    └── logging.py           # [CREATE] Logging setup
```

## 3. Design Architecture

### Configuration (`config_model.py`)
We use Pydantic V2 to define the schema.
-   `ExplorationConfig`: Controls sampling strategy (Cycle 01: just dummy params).
-   `DFTConfig`: Controls Quantum Espresso settings.
-   `TrainingConfig`: Controls Pacemaker settings.
-   `GlobalConfig`: Root object containing all sections.

### Domain Models (`structures.py`)
-   `StructureMetadata`: A lightweight wrapper around `ase.Atoms` (or a placeholder in Cycle 01) to track provenance (e.g., "generated by MD at step 5").

### Interfaces (`core_interfaces.py`)
We use `typing.Protocol` to enforce structural subtyping.
-   `Explorer`: Must implement `generate_candidates()`.
-   `Oracle`: Must implement `calculate()`.
-   `Trainer`: Must implement `train()`.
-   `Validator`: Must implement `validate()`.

### Orchestrator (`orchestrator.py`)
The orchestrator is a state machine. In Cycle 01, it performs a fixed number of iterations.
-   **Dependency Injection**: The orchestrator receives instances of Explorer, Oracle, etc., via its constructor. This allows us to inject Mocks easily.

## 4. Implementation Approach

1.  **Project Initialization**:
    -   Configure `pyproject.toml` (already exists, but verify dependencies).
    -   Setup `src` layout.

2.  **Define Interfaces**:
    -   Write `core_interfaces.py` defining the input/output types for each module.

3.  **Implement Mocks**:
    -   Create `MockExplorer` that returns random "dummy" structures.
    -   Create `MockOracle` that returns random energies/forces.
    -   Create `MockTrainer` that pretends to write a `.yace` file.

4.  **Implement Orchestrator**:
    -   Write the loop: `for cycle in range(N): ...`
    -   Add logging to visualize the flow.

5.  **CLI Entrypoint**:
    -   Use `typer` to create a command `mlip-pipeline run config.yaml`.

## 5. Test Strategy

### Unit Testing
-   **Config Validation**: Test that valid `config.yaml` loads correctly and invalid ones raise `ValidationError`.
-   **Orchestrator Logic**: Test that the orchestrator calls `explorer.generate()`, then `oracle.calculate()`, etc., in the correct order. We will use `unittest.mock.MagicMock` to spy on these calls.

### Integration Testing
-   **CLI Test**: Run the `mlip-pipeline` command with a dummy config file and capture standard output to ensure it runs through 6 cycles without crashing.
