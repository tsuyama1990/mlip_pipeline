# Cycle 01 Specification: Core Framework & User Interface

## 1. Summary

Cycle 01 lays the bedrock for the entire MLIP-AutoPipe ecosystem. Before any physics can be simulated or any potentials trained, we must establish a robust, type-safe, and verifiable infrastructure. The primary objective of this cycle is to implement the **Configuration Management System** and the **Core Utilities** (Database and Logging) that will serve as the nervous system of the application.

In many scientific software projects, configuration is handled via loose dictionaries or unstructured scripts, leading to "silent failures" where a typo in a parameter name causes the code to run with default values rather than user intent. To prevent this, we adopt a **Strict Schema** approach using Pydantic V2. This ensures that every input is validated *before* any expensive computation begins.

Additionally, we will establish the **Data Persistence Layer**. We will use `ase.db` (a wrapper around SQLite/PostgreSQL) but extend it to enforce our specific schema requirements, ensuring that no data is saved without its provenance metadata (e.g., "Which code version generated this?"). Finally, a centralized **Logging System** will be implemented to provide structured, machine-parsable logs, which are essential for debugging autonomous workflows running on remote HPC clusters.

By the end of this cycle, we will have a CLI tool that can initialize a project workspace, validate a complex configuration file, and establish a database connection, providing a solid foundation for the physics modules to follow.

## 2. System Architecture

This cycle focuses on the `mlip_autopipec/config` and `mlip_autopipec/core` directories, setting up the project skeleton.

```ascii
mlip_autopipec/
├── config/
│   ├── __init__.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── common.py       # Shared models (TargetSystem, UserInputConfig)
│   │   └── system.py       # Full SystemConfig
│   ├── models.py           # Exports all models
│   └── factory.py          # Logic to expand UserInputConfig -> SystemConfig
├── core/
│   ├── __init__.py
│   ├── database.py         # Database interface with schema enforcement
│   ├── logging.py          # Centralized logging setup
│   └── utils.py            # Shared utilities (Path handling, hashing)
├── app.py                  # CLI Entry point (Typer/Argparse)
└── __init__.py
tests/
├── test_config.py
├── test_config_factory.py
├── test_database.py
└── test_logging.py
pyproject.toml
```

### Key Components

1.  **`mlip_autopipec/config/models.py`**: This file defines the "Law" of the system. It exports `UserInputConfig` (what the user provides) and `SystemConfig` (the fully hydrated internal state). It uses Pydantic validators to ensure chemical symbols are valid, compositions sum to 1.0, and resource requests are sane.
2.  **`mlip_autopipec/config/factory.py`**: A Factory pattern implementation. It accepts a path to a YAML file, reads it, validates it against `UserInputConfig`, resolves relative paths to absolute paths, creates necessary directories (e.g., `workspace/run_01/`), and returns a `SystemConfig` object.
3.  **`mlip_autopipec/core/database.py`**: A wrapper class `DatabaseManager` around `ase.db`. It does not just "connect"; it manages the lifecycle of the connection, ensures thread safety (if using SQLite), and provides strict methods like `add_structure(atoms, metadata=...)` rather than generic `write()`.
4.  **`mlip_autopipec/core/logging.py`**: Sets up the Python logger. It configures a StreamHandler (for console output, colorful) and a FileHandler (for archival). It ensures that all modules use the same logging instance.

## 3. Design Architecture

### Domain Concepts

**Configuration as Code**:
The configuration is not merely a set of inputs; it is a code object. By typing it strictly, we enable IDE autocompletion and static analysis.
-   **User Input (`input.yaml`)**: Designed for humans. "Fe-Ni", "Melt-Quench". Implicit defaults.
-   **System State (`SystemConfig`)**: Designed for the machine. "/home/user/project/run_1/db.sqlite", "Target: Fe (Z=26), Ni (Z=28)". Explicit values.

**Provenance**:
Every piece of data generated by the system must answer the questions: "Where did I come from?" and "How was I made?".
-   **UUID**: Every structure gets a unique ID.
-   **Tags**: Every database entry gets tags like `generation=0`, `source=sqs`, `status=pending`.

### Data Models (Pydantic)

```python
# Conceptual Schema Preview

class TargetSystem(BaseModel):
    elements: List[str] # Validator: Check Periodic Table
    composition: Dict[str, float]

    @field_validator('composition')
    def check_sum(cls, v):
        if not math.isclose(sum(v.values()), 1.0):
            raise ValueError("Composition must sum to 1.0")
        return v

class Resources(BaseModel):
    dft_code: Literal["quantum_espresso", "vasp"] # Enums
    parallel_cores: int = Field(gt=0)
    gpu_enabled: bool = False

class UserInputConfig(BaseModel):
    project_name: str
    target_system: TargetSystem
    resources: Resources

class SystemConfig(BaseModel):
    # Composition over inheritance preferred
    minimal: UserInputConfig
    working_dir: Path
    db_path: Path
    log_path: Path

    model_config = ConfigDict(frozen=True) # Immutable
```

### Constraints & Invariants
1.  **Immutability**: The `SystemConfig` is created once at startup. It should not be modified at runtime.
2.  **Path Safety**: All paths in `SystemConfig` must be absolute. The Factory is responsible for resolving `~/` or `./`.
3.  **Schema Versioning**: The database metadata should include the version of the code and the schema version, allowing future migrations.
4.  **Singleton Database Connection**: We enforce a single `DatabaseManager` instance per process.

## 4. Implementation Approach

The implementation will follow a strict TDD loop.

1.  **Step 1: Pydantic Models (`schemas/common.py` etc.)**:
    -   Define `TargetSystem`. Add validators for elements (check against `ase.data.chemical_symbols`) and composition (sum close to 1.0).
    -   Define `Resources`. Add checks for positive cores.
    -   Define `UserInputConfig` incorporating the above.
    -   Define `SystemConfig`. It should contain the `UserInputConfig` and added fields like `working_dir` (Path).
2.  **Step 2: Config Factory (`factory.py`)**:
    -   Implement `ConfigFactory.from_yaml(path)`.
    -   Use `pyyaml` to load the file.
    -   Validate using `UserInputConfig.model_validate()`.
    -   Compute absolute paths. Use `pathlib.Path.resolve()`.
    -   Create the directory structure `mkdir(parents=True)`.
    -   Return `SystemConfig`.
3.  **Step 3: Database Manager (`database.py`)**:
    -   Implement `DatabaseManager`.
    -   Constructor takes `db_path`.
    -   Method `initialize()`: Checks if file exists. If not, calls `ase.db.connect`, and writes a `metadata` key containing the `SystemConfig.model_dump()`.
    -   Method `get_metadata()`: Reads back the config.
4.  **Step 4: Logging (`logging.py`)**:
    -   Implement `setup_logging(log_path)`.
    -   Use `logging.dictConfig` or manual setup.
    -   Ensure `rich` library is used for console output if available.
5.  **Step 5: App (`app.py`)**:
    -   Use `typer` to define the CLI.
    -   `def run(input_file: Path)`:
        -   `config = ConfigFactory.from_yaml(input_file)`
        -   `setup_logging(config.log_path)`
        -   `db = DatabaseManager(config.db_path)`
        -   `db.initialize()`
        -   `log.info("System initialized")`

## 5. Test Strategy

### Unit Testing Approach
Unit tests will focus on the correctness of the configuration parsing and the robustness of the utility functions.
-   **Config Validation**: We will create a suite of "bad" YAML files (missing keys, wrong types, invalid chemical symbols, negative core counts) and assert that `UserInputConfig` raises specific `ValidationError` types.
-   **Path Resolution**: We will test `ConfigFactory` with various path inputs (absolute, relative, user-expanded).
-   **Logging**: We will use the `caplog` fixture to verify that log messages are actually captured.

### Integration Testing Approach
Integration tests will verify the interaction between the Configuration, Filesystem, and Database.
-   **Startup Sequence**: We will simulate a full application startup.
-   **Database Persistence**: We will instantiate the `DatabaseManager`, add some dummy metadata, close the connection, and re-instantiate it.
-   **CLI Invocation**: We will use `typer.testing.CliRunner` to invoke the main command-line interface.
