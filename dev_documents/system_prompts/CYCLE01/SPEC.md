# Cycle 01 Specification: Foundation & Configuration

## 1. Summary

Cycle 01 lays the definitive groundwork for the MLIP-AutoPipe system. The primary objective of this cycle is to establish the core software infrastructure that will support all subsequent modules (Generator, Surrogate, DFT, Training, Inference). In any complex scientific software, the robustness of the data structures and the reliability of the configuration management are paramount. If these are weak, the entire system becomes fragile, leading to "silent failures" where simulations run but produce physical nonsense.

This cycle focuses on three key technical pillars:
1.  **Strict Configuration Management**: We will define the "Source of Truth" for the entire pipeline using **Pydantic V2**. This involves creating rigorous schemas that validate every user input—from material composition to DFT convergence thresholds—before a single calculation is run. This prevents "Garbage In, Garbage Out" and catches errors early (fail-fast principle). We will implement a hierarchical configuration model that aggregates settings for different modules (DFT, Training, Inference) while maintaining clear separation of concerns. The `TargetSystem` model is particularly crucial as it defines the chemical identity of the project.
2.  **Persistence Layer (Database)**: We will establish the interface to the database. Instead of ad-hoc file storage (which leads to "directory hell"), we will use `ase.db` (SQLite) wrapped in a custom `DatabaseManager`. This ensures that all atomic structures, whether generated by the SQS module or extracted from an MD simulation, are stored in a unified, queryable format with consistent metadata (tags). This manager will handle connection pooling (via SQLite's file locking), schema enforcement for custom key-value pairs, and transactional integrity.
3.  **Command Line Interface (CLI)**: We will create the entry point for the application using **Typer**. This CLI will provide the user with commands to initialize projects (`init`), validate configurations (`check-config`), and eventually run the pipeline. The CLI will be the primary interface for the user, so it must be intuitive, self-documenting, and provide colourful, clear feedback (using `Rich`).

By the end of this cycle, the system will not yet run physics simulations, but it will be able to read a complex configuration file, validate it against physical constraints (e.g., ensuring cutoffs are positive), initialize a structured database, and provide a developer-friendly API for storing and retrieving atomic data. This forms the "skeleton" upon which the muscles (physics engines) will be attached in later cycles.

## 2. System Architecture

The focus in this cycle is on the `config`, `core`, and `app` packages. The architecture follows a standard layered approach: CLI -> Services -> Domain Models -> Infrastructure. This ensures that the business logic (Services) is decoupled from the user interface (CLI) and the storage details (Infrastructure).

### File Structure
**bold** files are to be created or modified in this cycle.

```
mlip_autopipec/
├── **__init__.py**
├── **app.py**                  # CLI Entrypoint (Typer App)
├── config/
│   ├── **__init__.py**
│   ├── **models.py**           # Aggregated Configuration Model (The Root)
│   └── schemas/
│       ├── **__init__.py**
│       ├── **common.py**       # Shared Enums and Types (TargetSystem, Resources)
│       ├── **dft.py**          # DFT Configuration Schema (QE parameters)
│       ├── **training.py**     # Training Configuration Schema (Pacemaker parameters)
│       └── **inference.py**    # Inference Configuration Schema (LAMMPS parameters)
├── core/
│   ├── **__init__.py**
│   ├── **database.py**         # DatabaseManager (ASE-db wrapper)
│   ├── **logging.py**          # Centralized Logging Setup (Rich integration)
│   └── **services.py**         # Application Services (e.g., Config Validation)
└── data_models/
    ├── **__init__.py**
    └── **common.py**           # Domain Data Types (Enums like Status, ConfigType)
```

### Module Interactions
-   **`app.py`** imports `core.services`. It does *not* import `core.database` directly. It parses CLI args and passes them to the Service layer.
-   **`core.services`** imports `config.models` to instantiate the Pydantic classes (`MLIPConfig`). It calls `MLIPConfig.model_validate` to perform validation.
-   **`core.database`** is a standalone module that depends on `ase`. It is initialized by the `WorkflowManager` (later) or by the CLI `db` commands.
-   **`config.schemas`** are pure data classes. They depend only on `pydantic`.

### Data Dictionary

| Model Name | Field | Type | Description |
| :--- | :--- | :--- | :--- |
| **TargetSystem** | elements | List[str] | List of chemical symbols (e.g., `["Fe", "Ni"]`). |
| | composition | Dict[str, float] | Atomic fractions (e.g., `{"Fe": 0.7, "Ni": 0.3}`). |
| | crystal_structure | Optional[str] | Base structure (e.g., "fcc", "bcc", "hcp"). |
| **DFTConfig** | pseudopotential_dir | Path | Directory containing .UPF files. |
| | ecutwfc | float | Wavefunction cutoff energy (Ry). |
| | kspacing | float | Inverse K-point density (1/A). |
| | nspin | int | Spin polarization (1=off, 2=on). |
| **MLIPConfig** | target_system | TargetSystem | Nested target config. |
| | dft | DFTConfig | Nested DFT config. |
| | runtime | RuntimeConfig | Runtime paths. |

## 3. Design Architecture

### Configuration (Pydantic Models)
We utilize **Pydantic V2** for all configuration handling. This ensures strong typing and automatic validation. The configuration is hierarchical, mirroring the logical structure of the pipeline.

**Key Models:**

1.  **`TargetSystem`** (in `config/schemas/common.py`):
    -   `elements`: `List[str]` (e.g., `["Fe", "Ni"]`). Validator: Check against periodic table (using `ase.data.chemical_symbols`). This prevents users from entering typos like "Fee".
    -   `composition`: `Dict[str, float]` (e.g., `{"Fe": 0.7, "Ni": 0.3}`). Validator: Sum must be close to 1.0 within a tolerance ($1.0 \pm 1e-5$).
    -   `crystal_structure`: `Optional[str]` or Path to CIF. Used for initializing the base structure. If a string (e.g., "fcc"), it will be passed to `ase.build.bulk`.

2.  **`DFTConfig`** (in `config/schemas/dft.py`):
    -   `pseudopotential_dir`: `Path`. Validator: Must be an existing directory. This check happens at load time, not run time.
    -   `ecutwfc`: `float` (Wavefunction Cutoff). Constraint: `gt=0`. Typically 30-100 Ry.
    -   `kspacing`: `float` (K-point density). Constraint: `gt=0`. Recommended default: 0.15 (inverse Angstrom). Using spacing instead of a grid (e.g., 4x4x4) allows for consistent sampling across different cell sizes.
    -   `nspin`: `int` (1 or 2). Auto-detected if not provided, based on magnetic elements in `TargetSystem` (Fe, Co, Ni).

3.  **`RuntimeConfig`** (in `config/models.py`):
    -   `database_path`: `Path`. Location of the SQLite database. Default: `mlip.db`.
    -   `work_dir`: `Path`. Scratch directory for calculations. Default: `_work`.

**Validation Logic:**
The Pydantic models will use `@field_validator` and `@model_validator` to enforce physical constraints. For example, if the user specifies a `pseudopotential_dir` that is empty, the validation will fail immediately. This prevents the system from crashing 3 hours later when Quantum Espresso tries to read a file.

### Database Layer (`DatabaseManager`)
The `DatabaseManager` class abstracts the `ase.db` library. It enforces a consistent schema for metadata, which ASE's flexible key-value store does not strictly require.

-   **Schema Enforcement**: While SQLite is schema-less for the key-value pairs, our Manager will enforce that every structure added has specific keys:
    -   `status`: Enum (`pending`, `running`, `completed`, `failed`). This is the state machine flag.
    -   `config_type`: String (`sqs`, `md_snapshot`, `dimer`). This tracks provenance.
    -   `generation`: Integer (Active learning cycle index). 0 for initial data, 1+ for active learning.
    -   `uuid`: String (Unique identifier for provenance). Useful for tracking lineage.

-   **Methods**:
    -   `initialize()`: Creates the `.db` file and sets up indices on frequently queried columns (`status`, `generation`).
    -   `add_structure(atoms: Atoms, metadata: dict)`: Inserts an atom, merging the metadata into the key-value pairs. Returns the integer ID.
    -   `count(filters: dict)`: Wraps `db.count()`. Used by the Workflow Manager to decide transitions.
    -   `update_status(id: int, status: str)`: Atomic update of the status field.
    -   `get_pending_tasks()`: Returns a list of IDs where `status='pending'`.

### CLI (`app.py`)
We use **Typer** for its intuitive syntax (type hints -> CLI arguments) and help generation.

-   **Command**: `mlip-auto init`
    -   **Action**: Copies a template `input.yaml` (stored in the package data) to the current directory. This template contains commented-out examples for all fields.
-   **Command**: `mlip-auto check-config <file>`
    -   **Action**: Calls `services.load_config(file)`. If successful, prints a green "OK". If it raises `pydantic.ValidationError`, it catches the error, formats it nicely (showing the location of the error in the YAML), and exits with code 1.

### Logging (`core/logging.py`)
We use the **Rich** library to provide structured, coloured logging.
-   **Console Handler**: Formatted for human readability. Info level by default.
-   **File Handler**: `mlip.log`. Includes timestamps and module names. Debug level by default.
-   **Integration**: The logger will be a singleton initialized at app startup. All modules will do `logger = logging.getLogger(__name__)`.

## 4. Implementation Approach

1.  **Define Domain Primitives**: Start by creating `config/schemas/common.py`. Define the `Element` type and `TargetSystem` class. This is the bedrock.
2.  **Build Configuration Schemas**: Implement `dft.py`, `training.py`, and `inference.py`. Add validators (e.g., checking if paths exist) to make them robust. Aggregate them in `config/models.py` into a single `MLIPConfig` object.
3.  **Implement Logging**: Set up `core/logging.py`. Ensure it can be imported anywhere and just works. Test it with a simple script.
4.  **Develop Database Manager**: Create `core/database.py`. Implement the `initialize` method first. Then implement `add_structure` with a test case using a dummy ASE Atoms object. Ensure `count` works. Implement `update_status`.
5.  **Create Service Layer**: In `core/services.py`, implement `load_config(path: Path) -> MLIPConfig`. This function will handle the `yaml.safe_load` and then pass the dictionary to the Pydantic model, catching `ValidationError` and re-raising them with user-friendly messages.
6.  **Construct CLI**: in `app.py`, define the Typer app. Import the service functions. Wire the `check-config` command to `load_config`. Wire `init` to a file copy operation.
7.  **Manual Verification**: Run the CLI against valid and invalid YAML files to verify behaviour. Verify the database file is created.

## 5. Test Strategy

### Unit Testing
-   **Config Tests (`tests/test_config.py`)**:
    -   **Valid Case**: Load a fully populated YAML. Assert all fields match the expected types and values.
    -   **Invalid Types**: Pass a string for `ecutwfc` (expected float). Assert `ValidationError`.
    -   **Logic Errors**: Pass a negative cutoff. Assert `ValidationError`.
    -   **Missing Files**: Pass a non-existent path for `pseudopotential_dir`. Assert validation failure.
    -   **Composition Sum**: Pass `{"Fe": 0.5, "Ni": 0.1}`. Assert validation failure (sum != 1.0).
-   **Database Tests (`tests/test_database.py`)**:
    -   **Setup**: Use a temporary directory (pytest fixture). Initialize the DB.
    -   **CRUD**: Add an atom. Count it. Update its status. Delete it. Verify metadata is preserved.
    -   **Concurrency**: (Optional) Try to open two connections to check locking behaviour (SQLite handles this, but good to verify).
    -   **Queries**: Add atoms with different statuses. Verify `count(status='pending')` returns the correct number.

### Integration Testing
-   **CLI Test (`tests/test_cli.py`)**:
    -   We will use `typer.testing.CliRunner`.
    -   **Init Command**: Run `init`. Check if `input.yaml` is created on disk. Check its content.
    -   **Check Command**: Run `check-config` on the generated file. Assert exit code 0.
    -   **Failure Mode**: Write a broken config file. Run `check-config`. Assert exit code 1 and presence of specific error message in stdout.

This strategy ensures that the "Foundation" is solid. If the config or DB layers are buggy, everything built on top will fail. High test coverage here is non-negotiable.
