# Cycle 01 Specification: Core Framework & User Interface

## 1. Summary

Cycle 01 lays the bedrock for the entire MLIP-AutoPipe ecosystem. Before any physics can be simulated or any potentials trained, we must establish a robust, type-safe, and verifiable infrastructure. The primary objective of this cycle is to implement the **Configuration Management System** and the **Core Utilities** (Database and Logging) that will serve as the nervous system of the application.

In many scientific software projects, configuration is handled via loose dictionaries or unstructured scripts, leading to "silent failures" where a typo in a parameter name causes the code to run with default values rather than user intent. To prevent this, we adopt a **Strict Schema** approach using Pydantic V2. This ensures that every input is validated *before* any expensive computation begins.

Additionally, we will establish the **Data Persistence Layer**. We will use `ase.db` (a wrapper around SQLite/PostgreSQL) but extend it to enforce our specific schema requirements, ensuring that no data is saved without its provenance metadata (e.g., "Which code version generated this?"). Finally, a centralized **Logging System** will be implemented to provide structured, machine-parsable logs, which are essential for debugging autonomous workflows running on remote HPC clusters.

By the end of this cycle, we will have a CLI tool that can initialize a project workspace, validate a complex configuration file, and establish a database connection, providing a solid foundation for the physics modules to follow.

## 2. System Architecture

This cycle focuses on the `src/config` and `src/core` directories, setting up the project skeleton.

```ascii
mlip_autopipec/
├── src/
│   ├── __init__.py
│   ├── config/
│   │   ├── __init__.py
│   │   ├── **models.py**       # Pydantic models for Input/System config
│   │   └── **factory.py**      # Logic to expand minimal config -> SystemConfig
│   ├── core/
│   │   ├── __init__.py
│   │   ├── **database.py**     # Database interface with schema enforcement
│   │   ├── **logging.py**      # Centralized logging setup
│   │   └── **utils.py**        # Shared utilities (Path handling, hashing)
│   └── **app.py**              # CLI Entry point (Typer/Argparse)
├── tests/
│   ├── **test_config.py**
│   ├── **test_database.py**
│   └── **test_logging.py**
└── pyproject.toml
```

### Key Components

1.  **`src/config/models.py`**: This file defines the "Law" of the system. It contains the `MinimalConfig` (what the user provides) and `SystemConfig` (the fully hydrated internal state). It uses Pydantic validators to ensure chemical symbols are valid, compositions sum to 1.0, and resource requests are sane.
2.  **`src/config/factory.py`**: A Factory pattern implementation. It accepts a path to a YAML file, reads it, validates it against `MinimalConfig`, resolves relative paths to absolute paths, creates necessary directories (e.g., `workspace/run_01/`), and returns a frozen `SystemConfig` object.
3.  **`src/core/database.py`**: A wrapper class `DatabaseManager` around `ase.db`. It does not just "connect"; it manages the lifecycle of the connection, ensures thread safety (if using SQLite), and provides strict methods like `add_structure(atoms, metadata=...)` rather than generic `write()`.
4.  **`src/core/logging.py`**: Sets up the Python logger. It configures a StreamHandler (for console output, colorful) and a FileHandler (for archival). It ensures that all modules use the same logging instance.

## 3. Design Architecture

### Domain Concepts

**Configuration as Code**:
The configuration is not merely a set of inputs; it is a code object. By typing it strictly, we enable IDE autocompletion and static analysis.
-   **User Input (`input.yaml`)**: Designed for humans. "Fe-Ni", "Melt-Quench". Implicit defaults.
-   **System State (`SystemConfig`)**: Designed for the machine. "/home/user/project/run_1/db.sqlite", "Target: Fe (Z=26), Ni (Z=28)". Explicit values.

**Provenance**:
Every piece of data generated by the system must answer the questions: "Where did I come from?" and "How was I made?".
-   **UUID**: Every structure gets a unique ID.
-   **Tags**: Every database entry gets tags like `generation=0`, `source=sqs`, `status=pending`.

### Data Models (Pydantic)

```python
# Conceptual Schema Preview

class TargetSystem(BaseModel):
    elements: List[str] # Validator: Check Periodic Table
    composition: Dict[str, float]

    @field_validator('composition')
    def check_sum(cls, v):
        if not math.isclose(sum(v.values()), 1.0):
            raise ValueError("Composition must sum to 1.0")
        return v

class Resources(BaseModel):
    dft_code: Literal["quantum_espresso", "vasp"] # Enums
    parallel_cores: int = Field(gt=0)
    gpu_enabled: bool = False

class MinimalConfig(BaseModel):
    project_name: str
    target_system: TargetSystem
    resources: Resources

class SystemConfig(BaseModel):
    # Composition over inheritance preferred, but flat model easier for config
    minimal: MinimalConfig
    working_dir: Path
    db_path: Path
    log_path: Path

    model_config = ConfigDict(frozen=True) # Immutable
```

### Constraints & Invariants
1.  **Immutability**: The `SystemConfig` is created once at startup. It must effectively be a Singleton (though passed explicitly, not global). It should not be modified at runtime.
2.  **Path Safety**: All paths in `SystemConfig` must be absolute. The Factory is responsible for resolving `~/` or `./`.
3.  **Schema Versioning**: The database metadata should include the version of the code and the schema version, allowing future migrations.
4.  **Singleton Database Connection**: While SQLite allows multiple connections, `ase.db` can be tricky with locking. We enforce a single `DatabaseManager` instance per process (or managed via Dask later).

## 4. Implementation Approach

The implementation will follow a strict TDD loop.

1.  **Step 1: Pydantic Models (`models.py`)**:
    -   Define `TargetSystem`. Add validators for elements (check against `ase.data.chemical_symbols`) and composition (sum close to 1.0).
    -   Define `Resources`. Add checks for positive cores.
    -   Define `MinimalConfig` incorporating the above.
    -   Define `SystemConfig`. This should have `frozen=True`. It should contain the `MinimalConfig` and added fields like `working_dir` (Path).
2.  **Step 2: Config Factory (`factory.py`)**:
    -   Implement `ConfigFactory.from_yaml(path)`.
    -   Use `pyyaml` to load the file.
    -   Validate using `MinimalConfig.model_validate()`.
    -   Compute absolute paths. Use `pathlib.Path.resolve()`.
    -   Create the directory structure `mkdir(parents=True)`.
    -   Return `SystemConfig`.
3.  **Step 3: Database Manager (`database.py`)**:
    -   Implement `DatabaseManager`.
    -   Constructor takes `db_path`.
    -   Method `initialize()`: Checks if file exists. If not, calls `ase.db.connect`, and writes a `metadata` key containing the `SystemConfig.model_dump()`.
    -   Method `get_metadata()`: Reads back the config.
4.  **Step 4: Logging (`logging.py`)**:
    -   Implement `setup_logging(log_path)`.
    -   Use `logging.dictConfig` or manual setup.
    -   Ensure `rich` library is used for console output if available.
5.  **Step 5: App (`app.py`)**:
    -   Use `typer` to define the CLI.
    -   `def run(input_file: Path)`:
        -   `config = ConfigFactory.from_yaml(input_file)`
        -   `setup_logging(config.log_path)`
        -   `db = DatabaseManager(config.db_path)`
        -   `db.initialize()`
        -   `log.info("System initialized")`

## 5. Test Strategy

### Unit Testing Approach (Min 300 words)
Unit tests will focus on the correctness of the configuration parsing and the robustness of the utility functions.
-   **Config Validation**: We will create a suite of "bad" YAML files (missing keys, wrong types, invalid chemical symbols, negative core counts) and assert that `MinimalConfig` raises specific `ValidationError` types. This ensures that users get immediate, helpful feedback. We will also test "edge cases" like compositions summing to 0.999999 (should pass) vs 0.9 (should fail).
-   **Path Resolution**: We will test `ConfigFactory` with various path inputs (absolute, relative, user-expanded). We will use `tmp_path` fixture to ensure that the factory correctly creates the directory structure on the filesystem. We will verify that it handles spaces in paths correctly.
-   **Singleton Behavior**: We will verify that the `SystemConfig` object is immutable by attempting to set an attribute after creation and asserting that it raises `ValidationError` or `TypeError`.
-   **Logging**: We will use the `caplog` fixture to verify that log messages are actually captured at the correct levels (INFO vs DEBUG) and formatted correctly. We will ensure that sensitive info (if any) is not logged.

### Integration Testing Approach (Min 300 words)
Integration tests will verify the interaction between the Configuration, Filesystem, and Database.
-   **Startup Sequence**: We will simulate a full application startup. We will provide a valid `input.yaml`. We will assert that:
    1.  The working directory is created.
    2.  The `project.db` file is created inside it.
    3.  The `system.log` file is created inside it.
    4.  The database metadata correctly reflects the content of `input.yaml`.
-   **Database Persistence**: We will instantiate the `DatabaseManager`, add some dummy metadata, close the connection, and re-instantiate it. We will verify that the metadata persists and matches. We will also test concurrent access (basic check) to ensure no lock files remain if the process crashes.
-   **CLI Invocation**: We will use `typer.testing.CliRunner` to invoke the main command-line interface. We will check the exit code (0 for success, 1 for failure) and the standard output. This ensures that the wiring between the entry point and the core logic is correct and that the user sees the expected "Success" message.
