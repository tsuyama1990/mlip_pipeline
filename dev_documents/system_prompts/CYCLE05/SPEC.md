# Cycle 05 Specification: Dynamics (LAMMPS)

## 1. Summary
The "Dynamics Engine" is the proving ground for the MLIP. It uses the `potential.yace` generated by the Trainer to run molecular dynamics (MD) simulations. This cycle focuses on integrating LAMMPS, the industry-standard MD code. A critical feature of this implementation is the enforcement of **Hybrid Potentials**, where a physics-based baseline (ZBL/LJ) is overlaid on the machine-learned potential to prevent unphysical atomic overlaps and simulation crashes in unexplored high-energy regions.

## 2. System Architecture

Files in **bold** are to be created or modified.

```ascii
src/mlip_autopipec/
├── components/
│   ├── dynamics/
│   │   ├── **__init__.py**
│   │   ├── **base.py**             # BaseDynamics (ABC)
│   │   ├── **lammps_driver.py**    # Main Implementation
│   │   └── **hybrid.py**           # Hybrid Potential Utils
│   └── ...
└── core/
    └── **orchestrator.py**         # Update to use dynamics
```

## 3. Design Architecture

### 3.1 LAMMPS Driver (`lammps_driver.py`)

This class manages the lifecycle of a LAMMPS simulation.

**Responsibilities:**
*   **Input Script Generation**: Constructing `in.lammps` dynamically based on `DynamicsConfig` (ensemble, temperature, timesteps).
*   **Execution**: Running LAMMPS via `subprocess` (calling the binary `lmp_serial` or `lmp_mpi`) or via the `lammps` Python module (preferred if available).
*   **Output Parsing**: Reading thermodynamic output (log.lammps) and trajectory dumps (dump.lammps).

### 3.2 Hybrid Potential Logic (`hybrid.py`)

This utility ensures robustness. It generates the `pair_style` commands that combine ACE with a baseline.

**Logic:**
1.  **Baseline Selection**: Determine if `ZBL` (universal) or `LJ` (tuned) should be used.
2.  **Command Construction**:
    ```lammps
    pair_style hybrid/overlay pace zbl 1.0 2.0
    pair_coeff * * pace potential.yace Ti O
    pair_coeff * * zbl 22 8  # ZBL needs atomic numbers
    ```
3.  **Parameter Mapping**: Automatically map element symbols (e.g., 'Ti', 'O') to ZBL atomic numbers (22, 8).

## 4. Implementation Approach

1.  **Develop Hybrid Utils**: Implement `hybrid.py` to generate the complex pair style strings. Ensure it handles multi-component systems correctly.
2.  **Implement LAMMPS Driver**: Write `LAMMPSDynamics`. Use `ase.io.lammpsdata.write_lammps_data` to create the initial structure file.
3.  **Command Template**: Create a robust template for `in.lammps` that includes `thermo_style custom step temp press etotal` and `dump custom ... id type x y z fx fy fz`.
4.  **Integration**: Update `Orchestrator` to call `Dynamics.explore()`.

## 5. Test Strategy

### 5.1 Unit Testing
*   **Hybrid String Generation**: Verify `generate_pair_style(['Ti', 'O'])` returns the correct `hybrid/overlay` and `pair_coeff` lines with correct Z/Atomic Numbers.
*   **Input Script Validation**: Verify that the generated `in.lammps` contains all required fixes (npt/nvt) and computes.

### 5.2 Integration Testing
*   **Short MD Run**:
    *   Create a dummy system (e.g., 2 Argon atoms).
    *   Run `Dynamics.explore(steps=100)`.
    *   Verify `log.lammps` is created and contains thermodynamic data.
    *   Verify `dump.lammps` contains 100 frames (or whatever the dump frequency is).
    *   Check that atoms moved (positions changed).
